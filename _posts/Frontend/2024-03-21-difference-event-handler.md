---
title: "이벤트 핸들러를 호출하는 방식의 차이"
date: 2024-03-21 09:24:00 +0900
categories: [Frontend]
tags: [Frontend, TypeScript, Event Handler]
---

```typescript
1. const handleRemoveclick = (id: number, name: string) => {
  handleDelete({ id, name });
};

2. const handleRemoveClick = (id: number, name: string) => () => {
  handleDelete({ id, name });
};
```

이 두 코드를 호출하는 코드는 같을까?

> 답  
> ❌ 아니오 ❌

```typescript
  1. onClick={() => handleRemoveClick(id, name)}

  2. onClick={handleRemoveClick(id, name)}
```

<br>

# 두 함수의 정의

## 첫 번째

```typescript
const handleRemoveClick = (id: number, name: string) => {
  handleDelete({ id, name });
};
```

이 함수는 `id`와 `name`을 인자로 받고, 이를 사용하여 `handleDelete({id, name})` 함수를 즉시 실행한다. 이 형태는 주로 이벤트 핸들러 내부에서 직접 호출될 때 사용된다.

ex) 클릭 이벤트를 처리할 때 화살표 함수를 사용하여 `onClick` 이벤트에 연결할 수 있다.

```typescript
onClick={() => handleRemoveClick(id, name)}
```

이렇게 하면 사용자가 해당 요소를 클릭할 때 `handleRemoveClick` 함수가 실행되며, 이 함수는 다시 `handleDelete`를 호출하여 실제 삭제 로직을 수행한다.

<br>

## 두 번째

```typescript
const handleRemoveClick = (id: number, name: string) => () => {
  handleDelete({ id, name });
};
```

이 함수는 `id`와 `name`을 인자로 받지만, 즉시 `handleDelete`를 실행하지 않는다. 대신, `handleDelete`를 실행하는 새로운 함수를 반환한다. 이 방식은 컴포넌트의 이벤트 핸들러에서 직접 함수를 반환할 때 유용하다.

즉, `onClick`과 같은 이벤트에 직접 연결할 수 있다.

```typescript
onClick={handleRemoveClick(id, name)}
```

이 경우, 사용자가 요소를 클릭하면 `handleRemoveClick`에서 반환된 함수가 실행되며, 이 함수 내부에서 `handleDelete`가 호출된다. 이렇게 하면 추가적인 화살표 함수를 사용하지 않고도 파라미터를 전달할 수 있다.

<br>

## 요약

- 첫 번째 함수는 이벤트 핸들러에서 직접 호출하기 위한 함수이다. 이벤트 처리 시 화살표 함수를 통해 파라미터를 전달하며, 그 내부에서 `handleDelete`를 실행한다.
- 두 번째 함수는 이벤트 핸들러에서 바로 연결할 수 있는 함수를 반환한다. 이 함수는 사용자 정의 파라미터를 기반으로 `handleDelete`를 실행하는 새로운 함수를 생성하며, 추가적인 화살표 함수 없이 이벤트에 직접 연결될 수 있다.

<br>

# 이벤트 핸들러 내에서 직접 호출하기 위한 함수와 이벤트 핸들러에 바로 연결할 수 있는 함수의 차이

## 이벤트 핸들러 내에서 직접 호출하기 위한 함수

이 경우, 이벤트 핸들러는 또 다른 함수를 호출하기 위해 중간 단계(주로 화살표 함수)를 사용한다. 이 중간 단계는 이벤트 발생 시 특정 로직을 실행하기 전에 추가적인 작업을 수행할 수 있게 해준다.

ex) `onClick={() => myFunction(param1, param2)}`

- **장점**: 이 방식은 이벤트가 발생했을 때 추가적인 파라미터를 전달하거나, 이벤트 객체와 함께 다른 작업을 수행할 수 있도록 합니다. 또한, 조건부로 함수를 호출하거나 여러 함수를 연속적으로 호출하는 등의 복잡한 로직을 구현할 때 유용합니다.
- **단점**: 각 이벤트 핸들러마다 새로운 화살표 함수가 생성되므로, 컴포넌트가 다시 렌더링될 때마다 이 함수들도 재생성됩니다. 이는 <span style="background-color: #ffdce0;">메모리 사용량을 증가시킬 수 있으며, 성능에 영향을 줄 수 있습니다</span>(특히 대규모 어플리케이션에서).

<br>

## 이벤트 핸들러에 바로 연결할 수 있는 함수

이 방식은 함수를 반환하는 함수를 이용하여, 반환된 함수가 이벤트 핸들러로 직접 사용됩니다. 이 함수는 필요한 모든 파라미터를 미리 포함하고 있으며, 이벤트 발생 시 자동으로 실행됩니다.

ex) `onClick={myFunction(param1, param2)}`

- **장점**: 이 방식은 코드를 더 간결하게 만들며, 이벤트 핸들러와 직접적인 연결을 통해 추가적인 화살표 함수 없이도 파라미터를 전달할 수 있습니다. 또한, <span style="background-color: #ffdce0;">함수를 미리 준비함으로써 재사용성과 가독성을 높일 수 있습니다</span>.
- **단점**: 이 방식을 사용할 때는 함수가 함수를 반환하는 형태로 작성되어야 하며, 이는 코드의 복잡성을 증가시킬 수 있습니다. 또한, 함수의 반환 함수가 이벤트와 연결되기 때문에, 이벤트 처리 로직이 단일 함수로 분리되어 있지 않다면 관리가 어려울 수 있습니다.

<br>

## 결론

- **직접 호출**: 이벤트 핸들러 내에서 직접 함수를 호출하는 방식은 유연하고, 조건부 로직이나 추가적인 파라미터 전달이 필요할 때 유용합니다.
- **바로 연결**: 함수를 반환하는 함수를 이벤트 핸들러에 직접 연결하는 방식은 코드를 간결하게 만들고, 함수의 재사용성을 높일 수 있지만, 코드의 구조가 복잡해질 수 있습니다.

적절한 방식은 사용 사례와 개발자의 선호도, 그리고 어플리케이션의 성능 요구 사항에 따라 달라집니다. 간단하게 정리하자면:

- 이벤트 핸들러 내에서 **직접 호출하는 방식**은 <span style="background-color: #ffdce0;">추가적인 조건이나 파라미터를 다루어야 할 때, 또는 복잡한 로직을 실행해야 할 때 유용</span>합니다. 이 방식은 함수 호출에 더 많은 제어를 가능하게 하지만, <u>성능에 미묘한 영향을 줄 수 있으며 코드가 더 복잡</u>해질 수 있습니다.
- **바로 연결할 수 있는 함수**는 <span style="background-color: #ffdce0;">코드를 간결하게 유지하고, 특히 함수를 재사용할 때 유리</span>합니다. 이 방식은 코드의 가독성을 향상시키고, 이벤트 핸들러를 보다 명확하게 정의할 수 있도록 해줍니다. 하지만, 함수가 함수를 반환하는 형태는 <u>처음 접하는 사람에게는 다소 혼란을 줄 수 있으며, 코드의 구조를 이해하기 위해서는 추가적인 컨텍스트가 필요</u>할 수 있습니다.

<br>

# 그렇다면 성능적으로 더 좋은 것은?

성능 측면에서 두 접근 방식, 즉 이벤트 핸들러 내에서 직접 호출하는 방식과 이벤트 핸들러에 바로 연결할 수 있는 함수 방식 사이의 차이는 상황에 따라 달라질 수 있습니다. 그러나, 일반적인 관점에서 몇 가지 기본 원칙을 적용할 수 있습니다.

## 이벤트 핸들러 내에서 직접 호출

(`onClick={() => handleRemoveClick(id, name)}`)

이 방식은 각 이벤트 핸들러에 대해 새로운 함수 인스턴스를 생성합니다. 사용자가 요소를 클릭할 때마다, 새로운 화살표 함수가 생성되고 실행됩니다. 대규모 어플리케이션에서 수많은 요소에 대해 이 방식을 사용하면, 이벤트 핸들러가 자주 생성되고 소멸되면서 메모리 사용량이 증가하고 가비지 컬렉터의 부담이 커질 수 있습니다. 따라서, <span style="background-color: #ffdce0;">성능에 미묘하지만 부정적인 영향</span>을 줄 수 있습니다.

<br>

## 이벤트 핸들러에 바로 연결할 수 있는 함수

(`onClick={handleRemoveClick(id, name)}`)

이 접근 방식은 함수가 처음 정의될 때 파라미터를 포함하는 새로운 함수를 반환합니다. 이렇게 반환된 함수는 이벤트 핸들러로서 직접 사용되며, 추가적인 함수 생성 없이 재사용됩니다. 이 방식은 메모리 사용량을 줄이고, 함수 생성으로 인한 부하를 감소시킵니다. 결과적으로, <span style="background-color: #ffdce0;">보다 효율적인 메모리 관리와 가비지 컬렉션 부담 감소를 기대</span>할 수 있습니다.

<br>

## 결론

- <span style="background-color: #ffdce0;">성능을 최우선</span>으로 고려한다면, <span style="background-color: #ffdce0;">이벤트 핸들러에 바로 연결할 수 있는 함수 방식</span>이 더 좋습니다. 이 방식은 특히 리액트와 같은 라이브러리에서 컴포넌트가 빈번히 렌더링되고, 많은 수의 이벤트 핸들러가 사용될 때 성능 이점을 제공할 수 있습니다.
- 하지만, <span style="background-color: #ffdce0;">가독성과 코드의 간결성</span>을 더 중요하게 고려해야 하는 경우나, 특정 로직이나 조건에 따라 함수를 실행해야 하는 복잡한 시나리오에서는, 화살표 함수를 사용한 <span style="background-color: #ffdce0;">이벤트 핸들러 내에서 직접 호출하는 방식</span>이 더 적합할 수 있습니다.

이와 같이, 선택은 개발 상황, 어플리케이션의 성능 요구 사항, 그리고 개발 팀의 선호도에 따라 달라질 수 있습니다. 가능하다면, 성능 분석 도구를 사용하여 실제 어플리케이션에서의 영향을 테스트하고, 가장 적절한 방식을 결정하는 것이 좋습니다.
